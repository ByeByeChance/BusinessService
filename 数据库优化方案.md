# 数据库查询优化与读写分离实现方案

## 一、现状分析

### 1. 当前数据库配置
- 使用TypeORM 0.3.19作为ORM框架
- 单数据库连接配置，无读写分离
- 连接池大小根据CPU核心数动态调整

### 2. 现有查询问题
- 部分查询加载了不必要的关联数据
- 部分查询没有使用字段选择，加载了完整实体
- 关联查询使用方式不够优化

## 二、数据库查询优化建议

### 1. 优化关联查询

**问题**：在用户权限验证和菜单查询中，加载了不必要的关联数据。

**优化方案**：使用`select`指定只查询需要的字段，避免加载完整实体。

**修改示例**：

```typescript
// permission.guard.ts - 优化用户权限查询
const user = await this.userRepository.findOne({
  where: { id: userId },
  relations: ['role', 'role.menus'],
  select: {
    id: true,
    role: {
      id: true,
      name: true,
      menus: {
        id: true,
        permission: true
      }
    }
  }
});
```

### 2. 优化菜单查询

**问题**：menu.service.ts中的getMenuList方法查询了完整的用户和角色信息。

**优化方案**：只查询必要的字段，避免加载完整实体。

**修改示例**：

```typescript
// menu.service.ts - 优化菜单列表查询
async getMenuList(user: ICurrentUserType): Promise<ResultListVo<MenuItemVo>> {
  // 只查询用户的角色ID，不需要完整用户信息
  const userEntity = await this.UserRepository.findOne({
    where: { id: user.id },
    select: ['id', 'roleId']
  });
  
  if (!userEntity?.roleId) {
    throw new BadRequestException(`用户不存在或未分配角色`);
  }
  
  // 只查询角色的ID和名称，以及关联的菜单
  const roleEntity = await this.RoleRepository.findOne({
    where: { id: userEntity.roleId },
    relations: ['menus'],
    select: {
      id: true,
      name: true,
      menus: {
        id: true,
        parentId: true,
        name: true,
        path: true,
        component: true,
        icon: true,
        title: true,
        isHide: true,
        permission: true,
        type: true,
        sort: true
      }
    }
  });
  
  if (!roleEntity) {
    throw new BadRequestException(`角色不存在`);
  }
  
  const menus = roleEntity.name === 'admin' ? await this.getAllMenu() : roleEntity.menus || [];
  return {
    list: this.createMenuMethod(menus),
    total: menus.length,
    current: 1,
    pageSize: menus.length,
  };
}
```

### 3. 优化角色菜单分配

**问题**：role.service.ts中的assignMenusToRole方法加载了不必要的菜单信息。

**优化方案**：使用`findBy`和`In`操作符查询菜单，只加载必要的字段。

**修改示例**：

```typescript
// role.service.ts - 优化角色菜单分配
async assignMenusToRole(roleId: string, menuIds: string[]): Promise<string> {
  return await this.roleRepository.manager.transaction(async (transactionalEntityManager) => {
    const role = await transactionalEntityManager.findOne(RoleEntity, {
      where: { id: roleId },
      select: ['id']
    });
    
    if (!role) {
      throw new HttpException(`角色不存在`, HttpStatus.BAD_REQUEST);
    }
    
    // 只查询菜单的ID字段
    const insideMenus = await transactionalEntityManager.findBy(MenuEntity, {
      id: In(menuIds)
    }, {
      select: ['id']
    });
    
    const outsideMenuIds = menuIds.filter(id => !insideMenus.some(menu => menu.id === id));
    let msg = '';
    if (outsideMenuIds.length > 0) {
      msg += `, 部分菜单不存在: ${outsideMenuIds.join(', ')}`;
    }
    
    // 更新角色的菜单关联
    role.menus = insideMenus;
    await transactionalEntityManager.save(role);
    
    // 清除拥有该角色的所有用户的权限缓存
    const users = await transactionalEntityManager.find(UserEntity, {
      where: { roleId: roleId },
      select: ['id']
    });
    
    for (const user of users) {
      await this.cacheService.clearUserPermissionCache(user.id);
    }
    
    return `菜单权限分配成功${msg}`;
  });
}
```

### 4. 优化用户更新查询

**问题**：user.service.ts中的updateUser方法查询了完整的用户信息。

**优化方案**：只查询必要的字段，使用`update`方法直接更新数据。

**修改示例**：

```typescript
// user.service.ts - 优化用户更新
async updateUser(id: string, req: Partial<UserDto>): Promise<string> {
  // 只查询用户的ID和roleId，不需要完整用户信息
  const userEntity: Pick<UserEntity, 'id' | 'roleId'> | null = await this.userRepository.findOne({
    where: { id },
    select: ['id', 'roleId']
  });
  
  if (!userEntity?.id) {
    throw new BadRequestException(`用户不存在`);
  }
  
  // 更新用户信息
  const updateData: Partial<UserEntity> = {};
  if (req.username) {
    // 检查用户名是否已存在，只查询ID字段
    const existingUser = await this.userRepository.findOne({
      where: { username: req.username, id: Not(id) },
      select: ['id']
    });
    
    if (existingUser) {
      throw new BadRequestException(`用户名已存在`);
    }
    updateData.username = req.username;
  }
  
  if (req.email) updateData.email = req.email;
  if (req.status !== undefined) updateData.status = req.status;
  
  // 检查角色是否变化
  if (req.roleId !== undefined && req.roleId !== userEntity.roleId) {
    // 验证角色是否存在，只查询ID字段
    if (req.roleId) {
      const roleEntity: Pick<RoleEntity, 'id'> | null = await this.roleRepository.findOne({
        where: { id: req.roleId },
        select: ['id']
      });
      
      if (!roleEntity?.id) {
        throw new BadRequestException(`角色不存在`);
      }
    }
    updateData.roleId = req.roleId;
    
    // 清除用户权限缓存
    await this.cacheService.clearUserPermissionCache(id);
  }
  
  const { affected } = await this.userRepository.update(id, updateData);
  if (affected) {
    return '更新成功';
  } else {
    return '更新失败';
  }
}
```

## 三、读写分离实现

### 1. 修改配置文件

**在application.prod.yml中添加从数据库配置**：

```yaml
# 主数据库配置
primaryDatabase:
  host: localhost
  port: 3306
  username: root
  password: 123456
  database: algorithm_platform

# 从数据库配置
replicaDatabase:
  host: localhost
  port: 3307
  username: root
  password: 123456
  database: algorithm_platform
```

### 2. 修改TypeORM配置

**在app.module.ts中配置读写分离**：

```typescript
// app.module.ts - 配置读写分离
TypeOrmModule.forRootAsync({
  imports: [ConfigModule],
  inject: [ConfigService],
  useFactory: (configService: ConfigService) => ({
    type: 'mysql',
    // 主数据库配置
    host: String(configService.get('primaryDatabase.host')),
    port: Number.parseInt(configService.get('primaryDatabase.port') ?? '3306'),
    username: String(configService.get('primaryDatabase.username')),
    password: String(configService.get('primaryDatabase.password')),
    database: String(configService.get('primaryDatabase.database')),
    entities: [__dirname + '/**/*.entity{.ts,.js}'],
    logging: configService.get('datasource.logging'),
    timezone: '+08:00',
    synchronize: configService.get('datasource.synchronize') ?? false,
    cache: {
      duration: 60000, // 1分钟的缓存
    },
    autoLoadEntities: true,
    subscribers: [],
    migrations: [],
    cli: {
      entitiesDir: 'src/**/*.entity.ts',
      migrationsDir: 'src/migrations',
      subscribersDir: 'src/subscribers',
    },
    // 读写分离配置
    replication: {
      master: {
        host: String(configService.get('primaryDatabase.host')),
        port: Number.parseInt(configService.get('primaryDatabase.port') ?? '3306'),
        username: String(configService.get('primaryDatabase.username')),
        password: String(configService.get('primaryDatabase.password')),
        database: String(configService.get('primaryDatabase.database')),
      },
      slaves: [
        {
          host: String(configService.get('replicaDatabase.host')),
          port: Number.parseInt(configService.get('replicaDatabase.port') ?? '3307'),
          username: String(configService.get('replicaDatabase.username')),
          password: String(configService.get('replicaDatabase.password')),
          database: String(configService.get('replicaDatabase.database')),
        },
      ],
    },
    extra: {
      // 主库连接池配置
      master: {
        poolMax: Math.max(32, Math.min(64, os.cpus().length * 4)),
        poolMin: Math.max(16, Math.min(32, os.cpus().length * 2)),
      },
      // 从库连接池配置
      slave: {
        poolMax: Math.max(64, Math.min(128, os.cpus().length * 8)),
        poolMin: Math.max(32, Math.min(64, os.cpus().length * 4)),
      },
      queueTimeout: 30000,
      pollPingInterval: 30,
      pollTimeout: 60,
      acquireTimeout: 10000,
      waitForConnections: true,
    },
  }),
}),
```

### 3. 指定查询使用从库

**在查询方法中指定使用从库**：

```typescript
// 使用从库查询
const users = await this.userRepository.find({
  where: { status: 1 },
  // 指定使用从库
  loadStrategy: 'query',
});

// 使用主库查询（默认）
const user = await this.userRepository.findOne({
  where: { id: userId },
  // 显式指定使用主库
  loadStrategy: 'join',
});
```

## 四、性能监控与测试

### 1. 监控数据库连接池

项目已集成Prometheus监控，可以通过`/metrics`端点查看数据库连接池状态。

关键指标：
- `database_connections_used`：使用中的连接数
- `database_connections_idle`：空闲连接数
- `database_connections_pending`：等待中的连接数

### 2. 测试优化效果

- 使用`npm run build`构建项目，验证TypeScript编译通过
- 启动项目后，使用API测试工具测试权限验证和菜单查询功能
- 监控数据库查询性能，比较优化前后的响应时间

## 五、总结

通过以上优化措施，可以实现：

1. **减少数据传输**：只查询必要的字段，减少网络传输和内存占用
2. **提高查询性能**：优化关联查询，避免加载不必要的关联数据
3. **实现读写分离**：将读操作分散到从库，提高数据库整体吞吐量
4. **增强系统扩展性**：为后续的数据库集群扩展打下基础

建议逐步实施这些优化措施，并在生产环境中进行充分测试，以确保系统稳定性和性能提升。
